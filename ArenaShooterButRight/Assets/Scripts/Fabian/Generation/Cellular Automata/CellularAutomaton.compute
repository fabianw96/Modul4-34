#pragma kernel PrepareBuffer
#pragma kernel ApplyBuffer
#pragma kernel ApplyCellularAutomata

int3 size;

int get_uid(uint3 id)
{
	return id.x + (id.y * size.x) +(id.z * size.x * size.y);
}

struct Cell
{
	float3 CellPosition;
	// int IsAlive;
	int States;
};

RWStructuredBuffer<Cell> cells_buffer;
RWStructuredBuffer<Cell> cells;

int GetNeighborState(int3 neighborID)
{
	if(neighborID.x < 0 || neighborID.x >= size.x || neighborID.y < 0 || neighborID.y >= size.y || neighborID.z < 0 || neighborID.z >= size.z)
		return 0;

	Cell neighbor = cells[get_uid(neighborID)];
	return neighbor.States > 0 ? 1 : 0;
}


int ComputeNeighborsMoore(uint3 id)
{
	int neighborsCount = 0;

	for(int x = -1; x <= 1 ; ++x)
	{
		for(int y = -1; y <= 1 ; ++y)
		{
			for(int z = -1; z <= 1 ; ++z)
			{
				if(x != 0 || y != 0 || z != 0)
				{
					neighborsCount += GetNeighborState(id + int3(x,y,z));
				}
			}
		}
	}

	return neighborsCount;
}

int ComputeNeighborsNeumann(uint3 id)
{
	int neighborsCount = 0;

	neighborsCount += GetNeighborState(id - int3(1,0,0));
	neighborsCount += GetNeighborState(id + int3(1,0,0));
	neighborsCount += GetNeighborState(id - int3(0,1,0));
	neighborsCount += GetNeighborState(id + int3(0,1,0));
	neighborsCount += GetNeighborState(id - int3(0,0,1));
	neighborsCount += GetNeighborState(id + int3(0,0,1));

	return neighborsCount;
}

[numthreads(8,8,8)]
void ApplyCellularAutomata(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	Cell cell = cells[uid];

	//test moore first. Try and see if I can implement Neumann later.
	int neighborsCount = ComputeNeighborsMoore(id);

	if(cell.States > 0)
	{
		if(neighborsCount < 4)
		{
			cell.States -= 1;
		}
	}
	else
	{
		if(neighborsCount >= 4)
		{
			cell.States = 2;
		}
	}

	cells_buffer[uid] = cell;
}

[numthreads(8,8,8)]
void PrepareBuffer(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	cells_buffer[uid] = cells[uid];
}

[numthreads(8,8,8)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	cells[uid] = cells_buffer[uid];
}
