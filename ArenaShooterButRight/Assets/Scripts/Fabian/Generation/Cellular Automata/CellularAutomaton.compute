#pragma kernel ApplyCellularAutomata
#pragma kernel PrepareBuffer
#pragma kernel ApplyBuffer

int3 size;

int get_uid(uint3 id)
{
	return id.x + (id.y * size.x) +( id.z * size.y * size.z);
}

struct Cell
{
	int cell_game_object;
	float3 cell_transform;
	int is_alive;
	int states;
	int neighbors;
};

RWStructuredBuffer<Cell> cells_buffer;
RWStructuredBuffer<Cell> cells;

int GetNeighborState(int3 neighborID)
{
	if(neighborID.x >= size.x || neighborID.y >= size.y || neighborID.z >= size.z)
		return 0;

	Cell neighbor = cells[get_uid(neighborID)];
	return neighbor.is_alive;
}


int ComputeNeighborsMoore(uint3 id)
{
	int neighborsCount = 0;

	for(int x = -1; x <= 1 ; ++x)
	{
		for(int y = -1; x <= 1 ; ++y)
		{
			for(int z = -1; x <= 1 ; ++z)
			{
				if(x != 0 || y != 0 || z != 0)
				{
					neighborsCount += GetNeighborState(id + int3(x,y,z));
				}
			}
		}
	}

	return neighborsCount;
}

int ComputeNeighborsNeumann(uint3 id)
{
	int neighborsCount = 0;

	neighborsCount += GetNeighborState(id - int3(1,0,0));
	neighborsCount += GetNeighborState(id + int3(1,0,0));
	neighborsCount += GetNeighborState(id - int3(0,1,0));
	neighborsCount += GetNeighborState(id + int3(0,1,0));
	neighborsCount += GetNeighborState(id - int3(0,0,1));
	neighborsCount += GetNeighborState(id + int3(0,0,1));

	return neighborsCount;
}

[numthreads(8,8,8)]
void ApplyCellularAutomata(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	Cell cell = cells[uid];

	//test moore first. Try and see if I can implement Neumann later.
	int neighborsCount = ComputeNeighborsMoore(id);

	if(cell.is_alive)
	{
		if(neighborsCount < 4)
		{
			cell.states -= 1;
			if(cell.states <= 0)
			{
				cell.is_alive = 0;
			}
		}
	}
	else
	{
		if(neighborsCount >= 4)
		{
			cell.states = 2;
			cell.is_alive = 1;
		}
	}

	cells_buffer[uid] = cell;
}

[numthreads(8,8,8)]
void PrepareBuffer(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	cells_buffer[uid] = cells[uid];
}

[numthreads(8,8,8)]
void ApplyBuffer(uint3 id : SV_DispatchThreadID)
{
	int uid = get_uid(id);
	cells[uid] = cells_buffer[uid];
}
